#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define n 1000

float max_loss=1.01; // with value of 1.3 - I don't care if it takes 30% longer with pool than without
int cost[n][n];
int demand[n][2]; // from, to
int pool[n*n][3]; // three columns: custA, custB, cost; n*n is big enough

// compare func for Qsort
int cmp ( const void *pa, const void *pb ) {
    const int (*a)[3] = pa;
    const int (*b)[3] = pb;
    if ( (*a)[2] < (*b)[2] ) return -1;
    if ( (*a)[2] > (*b)[2] ) return +1;
    return 0;
}

void show_cost () {
    for (int i=0; i<n; i++) {
            printf ("%d: ", i);
            for (int j=0; j<n; j++) printf ("%3d ", cost[i][j]);
            printf ("\n");
        }
}

int main(void)
{
    int numb_cust = n; // maybe *2? twice as many customers than there are stops;
    int pool_numb = 0;
    time_t t;

    srand((unsigned) time(&t));

    for (int i=0; i<n; i++)
        for (int j=i; j<n; j++) {
            cost[j][i] = j-i; // simplification of distance - stop9 is closer to stop7 than to stop1
            cost[i][j]=cost[j][i] ;
        }
    for (int i=0; i<numb_cust; i++) {
        demand[i][0] = rand() % n; // 0: from 
        demand[i][1] = rand() % n; // 1: to
    }
    // now we have to remove incidental from=to generated by 'random'
    int length = numb_cust; // *2: let's have twice as much customers than there are stops;
    int i=0;
    while (i<length)
        if (demand[i][0]==demand[i][1]) {
            memmove(&demand[i], &demand[i+1], (length-i-1) * sizeof(demand[0]));
            length--;
        }
        else i++;

    numb_cust=length;

    printf ("DEMAND: customer number: from to:\n");
    //for (int i=0; i<numb_cust; i++)
    //    printf ("customer %d: %d %d\n", i, demand[i][0], demand[i][1]);
    //show_cost();

    for (int custA=0; custA < numb_cust; custA++)
      for (int custB=0; custB < numb_cust; custB++)
        if (custA != custB) {
            // 3 values in 2 plans: pick up B; go to A's destination, then go to B's destination OR
            // pick up B; go to B's destination, then go to A's destination
            int plan1=0, plan2=0; // false
            int cost2 = cost[demand[custA][0]][demand[custB][0]] +
                        cost[demand[custB][0]][demand[custB][1]] +
                        cost[demand[custB][1]][demand[custA][1]];

            if (cost[demand[custB][0]][demand[custA][1]] + cost[demand[custA][1]][demand[custB][1]]
                < cost[demand[custB][0]][demand[custB][1]]*max_loss && // cust B does not lose much with it
                cost[demand[custA][0]][demand[custB][0]] + cost[demand[custB][0]][demand[custA][1]]
                < cost[demand[custA][0]][demand[custA][1]]*max_loss // cust A does not lose much with it either
                ) plan1 = 1; //True
            if (cost2 < cost[demand[custA][0]][demand[custA][1]]*max_loss ) // cust A does not lose much with it, B never loses in this scenario
                plan2 = 1; //True
            if (plan1 || plan2) {
                int cost1 = cost[demand[custA][0]][demand[custB][0]] +
                            cost[demand[custB][0]][demand[custA][1]] +
                            cost[demand[custA][1]][demand[custB][1]];
                if (cost1<cost2) { // plan1 is better
                    /*printf ("Customer %d takes %d, customer %d ends the whole trip, total cost: %d (with(out) pool - customer %d: %d(%d), customer %d: %d(%d))\n",
                       custA, custB, custB, cost1,
                       custA, cost[demand[custA][0]][demand[custB][0]] + cost[demand[custB][0]][demand[custA][1]], cost[demand[custA][0]][demand[custA][1]],
                       custB, cost[demand[custB][0]][demand[custA][1]] + cost[demand[custA][1]][demand[custB][1]], cost[demand[custB][0]][demand[custB][1]]);
                    */
                    pool[pool_numb][2]=cost1;
                }
                else {
                    /*printf ("Customer %d takes %d, customer %d ends the whole trip, total cost: %d (with(out) pool - customer %d: %d(%d), customer %d: %d(%d))\n",
                       custA, custB, custA, cost2,
                       custA, cost2, cost[demand[custA][0]][demand[custA][1]],
                       custB, cost[demand[custB][0]][demand[custB][1]], cost[demand[custB][0]][demand[custB][1]]);
                    */
                    pool[pool_numb][2]=cost2;
                }
                pool[pool_numb][0]=custA;
                pool[pool_numb][1]=custB;
                pool_numb++;
            }
        }
    
    qsort(pool, pool_numb, sizeof pool[0], cmp );
    
//    for (int i=0; i<pool_numb; i++)
//         printf ("%d %d (%d)\n", pool[i][0], pool[i][1], pool[i][2]);
    // now we have to remove plans with same passengers
    int duplicates = 0;
    int in_pool[numb_cust];
    in_pool[0] = pool[0][0];
    in_pool[0] = pool[0][1];
    int in_pool_count=2;

    for (int i=1; i<pool_numb; i++) { // i does not start with 0 as [0] is the best plan in the set
        for (int j=0; j<in_pool_count; j++)
            if (pool[i][0]==in_pool[j] || pool[i][1]==in_pool[j]) { // the 'i' plan shares one participant with
                    //print ("Deleting (%d,%d) as (%d,%d) has this passenger " % (pool[i][0], pool[i][1],pool[j][0], pool[j][1]))
                    // list is sorted; i>j => delete 'i'
                pool[i][0]=-1; // mark as 'dropped'
                duplicates++;
                break;
            }
        if (pool[i][0] != -1) {
            in_pool[in_pool_count++] = pool[i][0];
            in_pool[in_pool_count++] = pool[i][1];
        }
    }
    

    printf ("After shared participants removed, pools -> customer numbers (cost):\n");
    int count=0;
    for (int i=0; i<pool_numb; i++)
    	if (pool[i][0]!=-1) // do not show dropped plans
    		//printf ("%d %d (%d)\n", pool[i][0], pool[i][1], pool[i][2]);
            count++;
    printf ("COUNT: %d DUPS: %d", count, duplicates);
}

